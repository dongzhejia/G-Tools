#!/usr/bin/env python
# coding=utf-8
# Filename: XTaskCollector.py
# :   
import sys
import os.path
import re
import click
import yaml

from . import logutil, XConfig, XIgnore, XPathTraveller
logger = logutil.getLogger()

TaskExt = '.xtask'
OptionExt = '.xopt'

# Error: Project not initialized
class OptionsConflictError(Exception):
    def __init__(self, target, tasktype, filepath1, filepath2):
        self.msg = "(\"%s/%s\") Options conflict in these files: \n\t%s\n\t%s" % \
            (target, tasktype, filepath1, filepath2)
    def __str__(self):
        return self.msg

class TaskNameRedundantError(Exception):
    def __init__(self, target, tasktype, taskname, filepath1, filepath2):
        self.msg = "(\"%s/%s\") Redundant tasks named \"%s\" in these files: \n\t%s\n\t%s" % \
            (target, tasktype, taskname, filepath1, filepath2)
    def __str__(self):
        return self.msg

class TaskOutputConflictError(Exception):
    def __init__(self, target, tasktype, output, idxinfo1, idxinfo2):
        task1 = idxinfo1["name"]
        filepath1 = idxinfo1["file"]
        task2 = idxinfo2["name"]
        filepath2 = idxinfo2["file"]
        self.msg = "(\"%s/%s\") Task output conflict: same output \"%s\" generated by: \n\t%s(%s)\n\t%s(%s)" % \
            (target, tasktype, output, task1, filepath1, task2, filepath2)
    def __str__(self):
        return self.msg

# XTaskCollector
class XTaskCollector(object):
    def __init__(self, xcfg, ignoreFilename=None):
        super(XTaskCollector, self).__init__()
        assert xcfg!=None, "No configuration object!"
        self._xcfg = xcfg
        self._userIgnoreRule = None
        self._pathTraveller = None

        projroot = xcfg.getProjectRoot()
        if ignoreFilename:
            try:
                if not os.path.isabs(ignoreFilename):
                    if projroot:
                        ignoreFilename = os.path.join(projroot, ignoreFilename)
                ignoreFile = open(ignoreFilename, "r")
                lines = ignoreFile.readlines()
                ignoreFile.close()
                userIgnoreRule = XIgnore.ZGitIgnore.fromLines(lines)
                userIgnoreRule.setIgnoreRoot(projroot)
                self._userIgnoreRule = userIgnoreRule
            except IOError as err:
                logger.warning("Failed to open ignore file \"%s\"" % ignoreFilename)

        self._pathTraveller = XPathTraveller.XPathTraveller()
        ignorePattern = xcfg.getValue("xtool.task", "ignoredirs", r'\..*')
        self._pathTraveller.setExcludedDirPattern(re.compile(r'^' + ignorePattern + r'$', re.I))
        fileExtensions = [TaskExt, OptionExt]
        namePattern = ("|".join(fileExtensions)).replace(r'.', r'\.')
        self._pathTraveller.setFilenameFilter(re.compile('.*(' + namePattern + ')$', re.I))
        self._pathTraveller.userIgnoreRule = self._userIgnoreRule

        self._tasks = {}

    def getRawTasksForTarget(self, target):
        allTasks = self._tasks
        if allTasks!=None and target in allTasks:
            return allTasks[target]
        return None

    def getRawTaskItemsForTargetType(self, target, tasktype):
        tasksOfTarget = self.getRawTasksForTarget(target)
        if tasksOfTarget!=None and tasktype in tasksOfTarget:
            return tasksOfTarget[tasktype]["items"]
        return None

    def getTaskTypesForTarget(self, target):
        generalTasks = self.getRawTasksForTarget("__ANY__")
        generalKeys = list(generalTasks.keys()) if generalTasks else []
        if target==None or target=="__ANY__":
            return generalKeys
        specificTasks = self.getRawTasksForTarget(target)
        specificKeys = list(specificTasks.keys()) if specificTasks else []
        return list(set(generalKeys + specificKeys))

    def mergeOptionsForTaskItems(self, taskItems, target):
        taskItemsCopy = []
        for taskItem in taskItems:
            itemCopy = dict(taskItem)
            itemOptions = itemCopy["options"]
            inheritedOptions = itemCopy.pop("inheritedOptions", {})
            finalOptions = {}
            if "__ANY__" in inheritedOptions:
                finalOptions = dict(finalOptions, **inheritedOptions["__ANY__"])
            if target != "__ANY__" and target in inheritedOptions:
                finalOptions = dict(finalOptions, **inheritedOptions[target])
            itemCopy["options"] = dict(finalOptions, **itemOptions)
            taskItemsCopy.append(itemCopy)
        return taskItemsCopy

    def getTaskItemsForTargetType(self, target, tasktype, filterFunction=None):
        generalTaskItems = self.getRawTaskItemsForTargetType("__ANY__", tasktype)
        if target==None or target=="__ANY__":
            taskItems = list(generalTaskItems) if generalTaskItems else []
            return self.mergeOptionsForTaskItems(self.filterTaskItems(taskItems, filterFunction), target)
        specificTaskItems = self.getRawTaskItemsForTargetType(target, tasktype)
        if not specificTaskItems:
            taskItems = list(generalTaskItems) if generalTaskItems else []
            return self.mergeOptionsForTaskItems(self.filterTaskItems(taskItems, filterFunction), target)
        if not generalTaskItems:
            taskItems = list(specificTaskItems) if specificTaskItems else []
            return self.mergeOptionsForTaskItems(self.filterTaskItems(taskItems, filterFunction), target)
        taskItems = self._mergeTaskItems(generalTaskItems, specificTaskItems)
        return self.mergeOptionsForTaskItems(self.filterTaskItems(taskItems, filterFunction), target)

    @staticmethod
    def filterTaskItems(taskItems, filterFunction):
        if filterFunction==None:
            return taskItems
        return list(filter(filterFunction, taskItems))

    def filterPatternForSubdirs(self, subdirs, recursive=True):
        if not subdirs:
            return None
        filterStrings = []
        for subdir in subdirs:
            projroot = self._xcfg.getProjectRoot()
            dirprefix = os.path.relpath(os.path.abspath(subdir), projroot)
            dirprefix = dirprefix.replace(os.sep, ">")
            if recursive:
                if dirprefix and dirprefix[0]!=".":
                    filterStrings.append(r"^" + re.escape(dirprefix) + r"[>|].*$")
                else:
                    # ignore the invalid subdir
                    pass
            else:
                filterStrings.append(r"^" + re.escape(dirprefix) + r"\|.*$")
        if not filterStrings:
            return None
        pattern = re.compile(r"|".join(filterStrings), re.I)
        return lambda x: pattern.match(x["fullname"])!=None

    def filterPatternForNames(self, names):
        if not names:
            return None
        filterStrings = []
        for name in names:
            if name.find("|")>=0:
                filterStrings.append(r"^" + re.escape(name) + r"$")
            else:
                filterStrings.append(r"^.*\|" + re.escape(name) + r"$")
        if not filterStrings:
            return None
        pattern = re.compile(r"|".join(filterStrings), re.I)
        return lambda x: pattern.match(x["fullname"])!=None

    def filterForExtensionOptions(self, extensions):
        if not extensions:
            return None
        return lambda x: "extension" in x["options"] and (x["options"]["extension"] & extensions > 0)


    def filterForExcludeExtensionOptions(self, extensions):
        if not extensions:
            return None
        return lambda x: 'extension' not in x["options"] or (x["options"]["extension"] & extensions == 0)

    def _mergeTaskItems(self, generalTaskItems, specificTaskItems):
        mergedTaskItems = []
        total = 0
        mergedIndices = {}
        len1 = len(generalTaskItems)
        len2 = len(specificTaskItems)
        i1, i2 = 0, 0
        while i1<len1 and i2<len2:
            task1 = generalTaskItems[i1]
            task2 = specificTaskItems[i2]
            if task1["prefix"]<=task2["prefix"]:
                name = task1["fullname"]
                if name not in mergedIndices:
                    mergedIndices[name] = (total, 1)
                    mergedTaskItems.append(task1)
                    total = total+1
                i1 = i1+1
            else:
                name = task2["fullname"]
                if name in mergedIndices:
                    info = mergedIndices[name]
                    idx = info[0]
                    mergedTaskItems[idx] = task2
                    mergedIndices[name] = (idx, 2)
                else:
                    mergedIndices[name] = (total, 2)
                    mergedTaskItems.append(task2)
                    total = total+1
                i2 = i2+1

        while i1<len1:
            task1 = generalTaskItems[i1]
            name = task1["fullname"]
            if name not in mergedIndices:
                mergedIndices[name] = (total, 1)
                mergedTaskItems.append(task1)
                total = total+1
            i1 = i1+1
        while i2<len2:
            task2 = specificTaskItems[i2]
            name = task2["fullname"]
            if name in mergedIndices:
                info = mergedIndices[name]
                idx = info[0]
                mergedTaskItems[idx] = task2
                mergedIndices[name] = (idx, 2)
            else:
                mergedIndices[name] = (total, 2)
                mergedTaskItems.append(task2)
                total = total+1
            i2 = i2+1

        return mergedTaskItems

    def loadCachedTasks(self, filepath=None):
        # TODO
        return False

    def cacheTasks(self, filepath=None):
        # TODO
        pass

    def collectAllTasks(self):
        projroot = self._xcfg.getProjectRoot()
        xfiles = self._collectXFiles(projroot)

        allTasks = {}
        self._recursiveContructTasks(xfiles, allTasks, None)
        self._tasks = allTasks

        # import json
        # print json.dumps(allTasks, indent=4)
        # print json.dumps(allTasks)

    def _collectXFiles(self, rootpath):
        print(rootpath)
        ACT_VISITFILE = XPathTraveller.ACT_VISITFILE
        ACT_ENTERDIR = XPathTraveller.ACT_ENTERDIR
        ACT_LEAVEDIR = XPathTraveller.ACT_LEAVEDIR

        xstack = []
        nameprefix = ""
        xfiles = {
            "prefix": nameprefix,
            "tasks": None,
            "opts": None,
            "subdirs": None,
        }
        xstack.append(xfiles)
        depth = 0
        for names, act in self._pathTraveller.walk(rootpath):
            if act==ACT_VISITFILE:
                shortName = names[2]
                name0, extname = os.path.splitext(shortName)
                if extname==TaskExt:
                    tasks = xfiles["tasks"]
                    if tasks==None:
                        xfiles["tasks"] = [names]
                    else:
                        tasks.append(names)
                elif extname==OptionExt:
                    opts = xfiles["opts"]
                    if opts==None:
                        xfiles["opts"] = [names]
                    else:
                        opts.append(names)
            elif act==ACT_ENTERDIR:
                depth = depth+1
                if depth>1:
                    nameprefix = (nameprefix + ">" + names[2]) if nameprefix else names[2]
                    xfiles = {
                        "prefix": nameprefix,
                        "tasks": None,
                        "opts": None,
                        "subdirs": None,
                    }
                    xstack.append(xfiles)
            elif act==ACT_LEAVEDIR:
                if depth>1:
                    subinfo = xstack.pop()
                    xfiles = xstack[-1]
                    nameprefix = xfiles["prefix"]
                    if subinfo["subdirs"] or subinfo["tasks"] or subinfo["opts"]:
                        subdirs = xfiles["subdirs"]
                        if subdirs==None:
                            xfiles["subdirs"] = [subinfo]
                        else:
                            subdirs.append(subinfo)
                depth = depth-1
        return xfiles

    def _recursiveContructTasks(self, xnode, tasks, inheritedOptions):
        baseOptions = inheritedOptions
        if xnode["opts"]:
            newOptions = self._processOptFiles(xnode["opts"], True)
            baseOptions = self._updateOptions(baseOptions, newOptions)
        if xnode["tasks"]:
            prefix = xnode["prefix"]
            for taskFileInfo in xnode["tasks"]:
                self._appendTasksInFile(tasks, prefix, taskFileInfo, baseOptions)
        if xnode["subdirs"]:
            for child in xnode["subdirs"]:
                self._recursiveContructTasks(child, tasks, baseOptions)

    def _loadOptionsFromFile(self, filename):
        allOptions = None
        optfile = None
        try:
            optfile = open(filename, "r")
            allOptions = {}
            for doc in yaml.load_all(optfile):
                target = doc["target"]
                items = doc["items"]
                allOptions[target] = items
        except Exception as e:
            logger.error("Failed to load options from \"%s\"" % filename)
            return None
        finally:
            if optfile:
                optfile.close()
        return allOptions

    def _processOptFiles(self, optfiles, check=False):
        optCheckInfo = {}
        numfiles = len(optfiles)
        mergedOptions = None
        for optFileInfo in optfiles:
            allOptions = self._loadOptionsFromFile(optFileInfo[0])
            if check and numfiles>1:
                for target, optionOfTasks in list(allOptions.items()):
                    tasks = None
                    if target in optCheckInfo:
                        tasks = optCheckInfo[target]
                    else:
                        tasks = {}
                        optCheckInfo[target] = tasks
                    for tasktype, options in list(optionOfTasks.items()):
                        if tasktype in tasks:
                            lastFileInfo = tasks[tasktype]
                            raise OptionsConflictError(target, tasktype, lastFileInfo[0], optFileInfo[0])
                        else:
                            tasks[tasktype] = optFileInfo
            mergedOptions = self._updateOptions(mergedOptions, allOptions)
        return mergedOptions

    def _updateOptions(self, originOptions, newOptions):
        if newOptions==None:
            return originOptions
        if originOptions==None:
            return newOptions
        resultOptions = dict(originOptions)
        for target, optionOfTasks in list(newOptions.items()):
            if target not in resultOptions:
                resultOptions[target] = optionOfTasks
            else:
                tasks = dict(resultOptions[target])
                resultOptions[target] = tasks
                for tasktype, options in list(optionOfTasks.items()):
                    if tasktype in tasks:
                        tasks[tasktype] = dict(tasks[tasktype], **options)
                    else:
                        tasks[tasktype] = options
        return resultOptions

    def _loadTasksFromFile(self, filename):
        allTasks = None
        taskfile = None
        try:
            taskfile = open(filename, "r")
            allTasks = {}
            for doc in yaml.load_all(taskfile):
                target = doc["target"]
                items = doc["items"]
                if target in allTasks:
                    logger.warning(
                        ("Multiple task section for target \"%s\" are found in \"%s\". " % (target, filename)) +
                        ("The last one will overwrite those before it. ") +
                        ("You should MERGE the items into one section.")
                    )
                tasks = {}
                allTasks[target] = tasks
                for name, task in list(items.items()):
                    tasktype = task["type"]
                    # task = dict({"name": name}, **task)
                    task["name"] = name
                    if tasktype in tasks:
                        tasks[tasktype].append(task)
                    else:
                        tasks[tasktype] = [task]
        except Exception as e:
            logger.error("Failed to load tasks from \"%s\"" % filename)
            return None
        finally:
            if taskfile:
                taskfile.close()
        return allTasks

    def _appendTasksInFile(self, tasks, prefix, taskFileInfo, inheritedOptions):
        newTasks = self._loadTasksFromFile(taskFileInfo[0])
        projroot = self._xcfg.getProjectRoot()
        optionsForTasks = {}
        if inheritedOptions:
            for target, taskOptions in list(inheritedOptions.items()):
                for taskType, options in list(taskOptions.items()):
                    if taskType in optionsForTasks:
                        optionsForTasks[taskType][target] = options
                    else:
                        taskOptionsForTargets = {}
                        taskOptionsForTargets[target] = options
                        optionsForTasks[taskType] = taskOptionsForTargets

        for target, newItems in list(newTasks.items()):
            tasksOfTarget = None
            if target in tasks:
                tasksOfTarget = tasks[target]
            else:
                tasksOfTarget = {}
                tasks[target] = tasksOfTarget

            for tasktype, tasksList in list(newItems.items()):
                tasksOfType = None
                if tasktype in tasksOfTarget:
                    tasksOfType = tasksOfTarget[tasktype]
                else:
                    tasksOfType = {
                        "items": [],
                        "nameIndices": {},
                        "outputIndices": {},
                    }
                    tasksOfTarget[tasktype] = tasksOfType
                taskItems = tasksOfType["items"]
                nameIndices = tasksOfType["nameIndices"]
                outputIndices = tasksOfType["outputIndices"]

                for task in tasksList:
                    taskpath = taskFileInfo[1]
                    fullname = prefix + ("|" + task["name"])
                    idxinfo = {
                        "file": taskFileInfo[0],
                        "name": task["name"],
                    }
                    if fullname in nameIndices:
                        file1 = nameIndices[fullname]["file"]
                        file2 = idxinfo["file"]
                        raise TaskNameRedundantError(target, tasktype, fullname, file1, file2)
                    outputs = task["output"]
                    if isinstance(outputs, list):
                        for output in outputs:
                            # 临时修改：Sync任务，则跳过相同输出检测
                            if tasktype=="Sync":
                                continue;
                            if output in outputIndices:
                                oldinfo = outputIndices[output]
                                raise TaskOutputConflictError(target, tasktype, output, oldinfo, idxinfo)
                        for output in outputs:
                            outputIndices[output] = idxinfo
                    elif outputs:
                        output = outputs
                        if output in outputIndices:
                            oldinfo = outputIndices[output]
                            raise TaskOutputConflictError(target, tasktype, output, oldinfo, idxinfo)
                        outputIndices[output] = idxinfo
                    nameIndices[fullname] = idxinfo
                    task["prefix"] = prefix
                    task["fullname"] = fullname
                    task["basepath"] = os.path.relpath(taskpath, projroot)

                    inputs = task["input"]
                    if isinstance(inputs, list):
                        for i in range(0, len(inputs)):
                            x = inputs[i]
                            if not os.path.isabs(x):
                                x = os.path.join(taskpath, x)
                            inputs[i] = os.path.relpath(x, projroot)
                    else:
                        if not os.path.isabs(inputs):
                            inputs = os.path.join(taskpath, inputs)
                        task["input"] = os.path.relpath(inputs, projroot)
                    if tasktype in optionsForTasks:
                        task["inheritedOptions"] = optionsForTasks[tasktype]
                    taskItems.append(task)
